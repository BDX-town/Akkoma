{"version":3,"sources":["webpack:///./app/soapbox/features/remote_timeline/index.js"],"names":["messages","defineMessages","title","RemoteTimeline","connect","state","props","instance","params","onlyMedia","getSettings","getIn","timelineId","hasUnread","injectIntl","e","context","router","history","push","maxId","dispatch","expandRemoteTimeline","componentDidMount","this","disconnect","connectRemoteStream","componentDidUpdate","prevProps","componentWillUnmount","render","intl","label","formatMessage","activeItem","active","className","icon","onClick","handleCloseClick","id","defaultMessage","values","scrollKey","onLoadMore","handleLoadMore","emptyMessage","React","PureComponent","PropTypes","object"],"mappings":"uSAYMA,EAAWC,YAAe,CAC9BC,MAAM,CAAD,0DAoBDC,EAFUC,kBAfQ,SAACC,EAAOC,GAC9B,IAAMC,EAAWD,EAAME,OAAOD,SAExBE,EADWC,YAAYL,GACFM,MAAM,CAAC,SAAU,QAAS,cAE/CC,EAAa,SAEnB,MAAO,CACLA,aACAH,YACAI,UAA2G,EAAhGR,EAAMM,MAAM,CAAC,YAAgBC,GAAaH,EAAY,SAAW,IAArD,IAA2DF,EAAY,WAC9FA,a,GAKHO,a,qMAuCoB,SAAAC,GACjB,EAAKC,QAAQC,OAAOC,QAAQC,KAAK,yB,4CAGlB,SAAAC,GAAU,IAAD,EACkB,EAAKd,MAAvCe,EADgB,EAChBA,SAAUZ,EADM,EACNA,UAAWF,EADL,EACKA,SAC7Bc,EAASC,YAAqBf,EAAU,CAAEa,QAAOX,iB,8CA7BnDc,kBAAA,WAAqB,IAAD,EACwBC,KAAKlB,MAAvCe,EADU,EACVA,SAAUZ,EADA,EACAA,UAAWF,EADX,EACWA,SAC7Bc,EAASC,YAAqBf,EAAU,CAAEE,eAC1Ce,KAAKC,WAAaJ,EAASK,YAAoBnB,EAAU,CAAEE,gB,EAG7DkB,mBAAA,SAAmBC,GACjB,IAAkD,EACxCP,EAAUZ,EAAWF,EAD3BqB,EAAUnB,YAAce,KAAKlB,MAAMG,YAC7BY,GADwC,EACNG,KAAKlB,OAAvCe,SAAUZ,EAD8B,EAC9BA,UAAWF,EADmB,EACnBA,SAC7BiB,KAAKC,aAELJ,EAASC,YAAqBf,EAAU,CAAEE,eAC1Ce,KAAKC,WAAaJ,EAASK,YAAoBnB,EAAU,CAAEE,iB,EAI/DoB,qBAAA,WACML,KAAKC,aACPD,KAAKC,aACLD,KAAKC,WAAa,O,EAatBK,OAAA,WAAU,IAAD,EACsDN,KAAKlB,MAA1DyB,EADD,EACCA,KAAMlB,EADP,EACOA,UAAWJ,EADlB,EACkBA,UAAWG,EAD7B,EAC6BA,WAAYL,EADzC,EACyCA,SAEhD,OACE,YAAC,IAAD,CAAQyB,MAAOD,EAAKE,cAAcjC,EAASE,aAA3C,EACE,YAAC,IAAD,CAAkBgC,WAAW,YAAYC,OAAQtB,IACjD,mBAAKuB,UAAU,gCAAf,EACE,YAAC,IAAD,CAAYC,KAAK,QAAQC,QAASd,KAAKe,mBACvC,YAAC,IAAD,CACEC,GAAG,iCACHC,eAAe,8CACfC,OAAQ,CAAEnC,eAGd,YAAC,IAAD,CACEoC,UAAc/B,EAAL,IAAmBL,EAAnB,YACTK,WAAeA,GAAaH,EAAY,SAAW,IAAzC,IAA+CF,EACzDqC,WAAYpB,KAAKqB,eACjBC,aACE,YAAC,IAAD,CACEN,GAAG,sBACHC,eAAe,8EACfC,OAAQ,CAAEnC,kB,GArEKwC,IAAMC,e,6BAEX,CACpB/B,OAAQgC,IAAUC,S","file":"js/features/remote_timeline-7bb5e0966fa4a9e3a8c1.chunk.js","sourcesContent":["import React from 'react';\nimport { connect } from 'react-redux';\nimport { defineMessages, injectIntl, FormattedMessage } from 'react-intl';\nimport PropTypes from 'prop-types';\nimport StatusListContainer from '../ui/containers/status_list_container';\nimport Column from '../../components/column';\nimport HomeColumnHeader from '../../components/home_column_header';\nimport IconButton from 'soapbox/components/icon_button';\nimport { expandRemoteTimeline } from '../../actions/timelines';\nimport { connectRemoteStream } from '../../actions/streaming';\nimport { getSettings } from 'soapbox/actions/settings';\n\nconst messages = defineMessages({\n  title: { id: 'column.remote', defaultMessage: 'Federated timeline' },\n});\n\nconst mapStateToProps = (state, props) => {\n  const instance = props.params.instance;\n  const settings = getSettings(state);\n  const onlyMedia = settings.getIn(['remote', 'other', 'onlyMedia']);\n\n  const timelineId = 'remote';\n\n  return {\n    timelineId,\n    onlyMedia,\n    hasUnread: state.getIn(['timelines', `${timelineId}${onlyMedia ? ':media' : ''}:${instance}`, 'unread']) > 0,\n    instance,\n  };\n};\n\nexport default @connect(mapStateToProps)\n@injectIntl\nclass RemoteTimeline extends React.PureComponent {\n\n  static contextTypes = {\n    router: PropTypes.object,\n  };\n\n  static propTypes = {\n    dispatch: PropTypes.func.isRequired,\n    intl: PropTypes.object.isRequired,\n    hasUnread: PropTypes.bool,\n    onlyMedia: PropTypes.bool,\n    timelineId: PropTypes.string,\n    instance: PropTypes.string.isRequired,\n  };\n\n  componentDidMount() {\n    const { dispatch, onlyMedia, instance } = this.props;\n    dispatch(expandRemoteTimeline(instance, { onlyMedia }));\n    this.disconnect = dispatch(connectRemoteStream(instance, { onlyMedia }));\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.onlyMedia !== this.props.onlyMedia) {\n      const { dispatch, onlyMedia, instance } = this.props;\n      this.disconnect();\n\n      dispatch(expandRemoteTimeline(instance, { onlyMedia }));\n      this.disconnect = dispatch(connectRemoteStream(instance, { onlyMedia }));\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.disconnect) {\n      this.disconnect();\n      this.disconnect = null;\n    }\n  }\n\n  handleCloseClick = e => {\n    this.context.router.history.push('/timeline/fediverse');\n  }\n\n  handleLoadMore = maxId => {\n    const { dispatch, onlyMedia, instance } = this.props;\n    dispatch(expandRemoteTimeline(instance, { maxId, onlyMedia }));\n  }\n\n  render() {\n    const { intl, hasUnread, onlyMedia, timelineId, instance } = this.props;\n\n    return (\n      <Column label={intl.formatMessage(messages.title)}>\n        <HomeColumnHeader activeItem='fediverse' active={hasUnread} />\n        <div className='timeline-filter-message'>\n          <IconButton icon='close' onClick={this.handleCloseClick} />\n          <FormattedMessage\n            id='remote_timeline.filter_message'\n            defaultMessage='You are viewing the timeline of {instance}.'\n            values={{ instance }}\n          />\n        </div>\n        <StatusListContainer\n          scrollKey={`${timelineId}_${instance}_timeline`}\n          timelineId={`${timelineId}${onlyMedia ? ':media' : ''}:${instance}`}\n          onLoadMore={this.handleLoadMore}\n          emptyMessage={\n            <FormattedMessage\n              id='empty_column.remote'\n              defaultMessage='There is nothing here! Manually follow users from {instance} to fill it up.'\n              values={{ instance }}\n            />\n          }\n        />\n      </Column>\n    );\n  }\n\n}\n"],"sourceRoot":""}